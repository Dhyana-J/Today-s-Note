<생활코딩>

@예외처리

try {} -> 예외 발생 가능성 문장을 감싸자. 

catch{} -> 예외가 발생 했을 경우 실행할 문장을 써주자.

finally{} -> 예외가 발생하든 안하든 실행될 문장을 써주자. 예외 발생할 경우 catch문 갯수 만큼 실행된다. (생활코딩 참고하자)

throws -> 메소드에서 throws를 해주는 경우 해당 메소드에서 예외처리를 하지 않고 그 메소드를 사용하는 주체가 예외처리하도록 한다.



<KH>

@배열!


//arr2 = arr1.clone(); -> 이거 배열 길이 똑같아진다. 배열 긴곳에다 배열 작은거 clone하면 긴배열 싹둑 잘린다. 반대는 늘어난다! 

//Arrays.copyOf(복사기준배열, 복사기준배열[0]에서 몇개뽑아올지) 얘는 복사받는배열[0]부터 채워넣는다.

//arraycopy(복사기준배열, 복사기준배열의 복사시작할 인덱스, 복사받는배열, 복사받는배열 복사받는시작점인덱스, 복사기준배열의 복사시작할 인덱스부터 몇개 뽑을지)
		//ArrayIndexOutOfBound 주의!

위의 세 가지 방법은 새로운 객체를 생성해서 저장하는 방법이다. 


int a[] = new int[5]; 
int b[] = a;

이런 식으로 저장하는 경우, b는 Stack에 a와 같은 값을 가지고 있다. heap을 공유한다.


@ 배열의 시작 주소값을 볼 수 있는 method
배열명.hashCode(); 이건 객체를 구분하기 위한 정수값(객체번호라고 이해하면 될듯)일뿐이다. 
println(배열명); 배열의 시작 주소가 출력된다. '타입@주소값(16진수)'형식으로 출력된다.
'타입@주소값' 의 주소값은 hashCode()로 나타난 10진수 정수값을 16진수로 변환한 것과 같다. 


@ 한번 생성된 배열객체의 길이는 변경할 수 없다! 강제로 삭제하고싶음 null값 넣으면 된다.
있던 기존 배열 = new 자료형[index]; 하면 시작 주소가 다른 새로운 길이의 배열인 객체가 heap에 생성된다. 
heap에 존재하던 기존의 있던 배열은 GC에 의해 청소된다.


궁금한점?
String a 에 쓰는 .equals랑
배열에 쓰는 .equals 이거 차이 알자. 그리고 equals 메소드 확실히 알아보자
String의 값이 같으면 같은 주소값을 가진다. 스트링풀에서 같은 내용이 있기 때문에 그걸 가리키도록 한다. ==랑 차이는 ?.... 
->내부적으로 기능 차이다. ==는 참조비교(주소비교) .equals()는 객체내용비교다.
하지만 배열에쓰면 .equals가 참조비교처럼동작하므로 Array.equals()를 통해 배열의 내용비교를 할 수 있게끔 할 수 있다.
