<생활코딩>

@ 접근 제어자 (Access Modifier)

*클래스 멤버의 접근 제어자는 네 가지가 있다 (public, private, default(암것도 안쓰는 경우), protected)

public -> 같은패키지, 다른패키지 전부 접근 허용

protected -> 같은패키지 전부 허용, 다른패키지 상속관계까지만 허용

default(접근제어자 안쓰는 경우) -> 같은패키지 전부 허용. 다른패키지 접근불가

private -> 같은패키지의 같은 클래스만 접근 허용!


*클래스의 접근 제어자는 두 가지가 있다. (public, default(암것도 안쓰는 경우)

간단하다. 

public이면 다른 패키지에서도 접근 가능! (public 클래스는 하나의 소스 코드에 하나만 존재할 수 있다.
그래서 소스 코드 파일명이랑 public클래스명이랑 같아야한다.)

default면 같은 패키지에서만 접근 가능!

-----------------------------------------------------

@abstract
-> 상속을 강제하는 일종의 규제. abstract 클래스나 메소드를 쓰려면, 반드시 상속해서 사용해야한다.

메소드에 {} 와 같은 본체가 있으면, abstract를 사용할 수 없다.

abstract class 안에는 abstract 메소드, 그냥 메소드 다 존재할 수 있다. 
추상메소드를 하나라도 포함하는 클래스가 abstract class!

추상클래스는 구체적인 메소드의 내용이 존재하지 않을 수 있으므로, 인스턴스화가 불가하다. 
그래서 상속을 통해 하위클래스에서 해당 추상메소드를 오버라이딩 한 후 그 하위클래스를 인스턴스화 할 수 있다.

@final
-> 추상과 달리 상속이나 변경을 못하도록 하는 것. 변수 메소드 클래스에 다 쓰인다.

---------------------------------------------------

@인터페이스(Interface)
-> 어떤 객체가 있고, 그 객체가 특정 인터페이스를 사용한다면, 그 객체는 반드시 인터페이스의 메소드들을 구현해야만한다.
	구현 안하면 컴파일 불가! 
인터페이스도 상속이 가능하다. 하위인터페이스는 상위인터페이스를 전부 포함한다.
인터페이스의 멤버는 가장 개방적인 접근제어자인 public으로 고정이다. 그러므로 제어자 생략하면 public이 기본상태다.


***인터페이스와 추상 클래스의 차이?
추상클래스는 내부에 몸체가 있는 메소드를 가질 수 있다. 인터페이스는 그렇지 않다.
추상클래스는 일반적인 클래스이고, 인터페이스는 고유한 형태를 가지고있다.

------------------------------------------------

@다형성 (Polymorphism)
->동일한 조작방법으로 동작시키지만 동작 방법은 다른 것. 동일한 행위를 하는데 결과가 다른 것.





<KH>

커리큘럼 NCS 능력단위 기존 절차랑 조금 달라진다. 
현재 커리큘럼은 순서가 이해하기 더 어렵게 되어있어서, 
강사님이 이해하기 쉽게끔 바꿀 예정. 커리큘럼 변경 동의서 제출 필요. . . .완료!


@산술연산자

증감연산 하는거

int a = 5;

int b = ++a;

이렇게 쓴다 하면 
결과적으로 a = 6, b = 6; 이렇게 된다. 다른 식에서 a에 대해 단항연산 이루어져도 a값이 변경된다!
a++; 만으로 대입연산 이루어짐.

@논리연산자.
-> || 연산자 기준으로 연산식이 있을 때 앞의 결과가 true값이 나오면, 뭘 해도 true이므로 뒤의 연산은 실행되지 않는다.
->&& 연산자는 그 반대. 앞에 false가 나오면 뒤엔 실행 안됨
그래서 이런 num < 20 || ++num  > 0; 이런 연산을 수행할 경우(&&도 마찬가지) ++num가 수행되지 않을 수 있다.