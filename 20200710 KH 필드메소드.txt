
<KH>

@필드

필드는 클래스 전역에서 접근할 수 있는 변수를 의미한다.

만약 인스턴스들이 사용하는 메소드나 변수가 중복된다면 (값이 같다면! 또는 메소드가 인스턴스변수를 사용하지 않는다면!)
그 때 static을 통해 클래스변수나 클래스메소드로 지정해주면 메모리를 아낄 수 있다.

항상 "중복"을 주의하자. 줄일 수 있으면 줄여서 성능을 향상시키자. 
왜? 하드웨어의 능력치에는 한계가 있으니까 (메모리, 연산속도 등 성능!)

ex) Math 클래스의 메소드들은 인스턴스 변수 생성 안하고 바로 쓸 수 있다. (static) 
하지만 Scanner의 경우 인스턴스 생성 하고 써야한다. (non-static)
	

@생성자

생성자는 인스턴스(객체)를 생성해주는 특수한 메소드! 반환값을 갖지 않는다.
또한, 매개변수를 포함한 생성자는 객체 생성과 동시에 매개변수를 통해 객체 내부 변수들을 초기화시켜줄 수 있다!
그렇게 하면 매개변수 값을 입력하지 않은 경우 객체 생성이 안되도록 해서, 큰 오류를 예방할 수 있다.

기본생성자는 기술 안해주면 JVM이 알아서 만들어준다.
매개변수 생성자 만들면, JVM이 기본생성자 알아서 안만들어준다.

this()는 같은 클래스의 생성자에서 다른 생성자를 호출 시 사용한다. 반드시 첫 줄에 써야한다!

생성자 조합에 따라, 인스턴스 객체 형성 시에 매개변수 조합을 여러개로 할 수 있다.
- 매개변수를 넣어도되고(매개변수 생성자 생성), 
- 안넣어도되고(기본생성자만 형성),
- 일부만 넣어도 되고(매개변수 생성자로 일부 변수만 초기화), 
- 일부만 넣으면 생성자에서 this()를 통해 다른건 특정 값으로 초기화시킨다던가
 (일부 변수만 초기화하는 생성자 this()로 불러와서 특정 값 넣어주고, 나머진 매개변수 입력받도록해 초기화)
오케이?

*생성자에 private을 붙이는 경우
해당 클래스의 인스턴스 생성을 막도록 할 수 있다. 해당 클래스가 특정 용도로만 쓰여야할 경우 쓰자.
생활코딩 - enum 참고!! (enum의 생성자는 private이 고정이다.)

*상속관계인 경우
super class에 매개변수 생성자만 있다면,

subclass에서는 super(); 를 한번 해줘야한다. 부모클래스의 기본생성자를 자동으로 생성안해준다.
super()는 부모클래스의 기본생성자를 가리킨다.
또한, subclass에서 super를 활용해 부모클래스의 생성자를 사용할 수 있다.


@패키지 만들 때
model.vo -> value object를 뜻함. 객체들에 대한 것.

controller -> method에 대한 것.

@static 메소드
언제쓸까? -> static변수에 접근하기위해 쓰는 메소드이다. static은 객체 생성이 필요 없다.  


<생활코딩>
enum 텍스트만 보면 이해 잘 안가니까 영상으로 한번 볼 것!

참조 제네릭 공부하자. 


<호기심 공부>

primitive type은 stack상에 그냥 바로 값과 함께 저장된다. 
ex) int i = 9; 이런 식으로 스택에 바로 들어간다.



