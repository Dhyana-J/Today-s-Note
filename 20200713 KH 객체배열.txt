

<KH>

@객체배열?

2차원 배열처럼 생성된다.

배열의 변수는 "열의 시작주소를 저장"하는 "행의 주소"를 가리킨다. 행의 각각 인덱스는 "열(객체or구조체)의 시작주소"를 저장한다.

객체를 배열마냥 인덱스 하나 하나에 따로따로 저장할 수 있다!

ex) Book[] bArr = new Book[5];

이런식으로 객체들이 저장될 Book[]의 주소 따로, 객체들의 주소(Book[0]이라던가) 따로 저장된다.

만약 
Book b = new Book();
bArr[0] = b;

해놓으면 

bArr[0]의 주소와 b의 주소는 같을까 다를까??

확인해본 결과 같다!  bArr[0]의 객체를 new로 선언하지 않았기 때문에,

객체 b의 주소를 참조하는 것으로 보인다.

new로 객체를 선언하면 내용이 다 같아도 새로운 주소가 생성된다.


@overloading

말 그대로 과적! 이름이 똑같은 함수를 또 만든다. 

똑같은 이름의 함수를 또 선언하고 매개변수만 다르게받는다(매개변수 갯수, 순서가 달라야한다. 매개변수명은 상관없음. 반환형 상관없음. 접근제한자 상관없음) 

똑같은 함수인데, 매개변수를 다양하게 해서 만들어두면, 입력 값에 따라 다양하게 함수가 실행되도록 할 수 있다.

ex)println도 여러 종류로 오버로딩되어있다.


